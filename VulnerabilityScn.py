import requests
import json
import sqlite3
from bs4 import BeautifulSoup
import time
import subprocess

class VulnerabilityScanner:
    def __init__(self, url):
        self.url = url
        self.payloads = self.load_payloads()
        self.scan_time = int(time.time())  # Get the current timestamp


    def load_payloads(self):
        with open("payloads.json", "r") as f:
            return json.load(f)
    
    def perform_header_scan(self):
        print("Performing Header Scan...")
        response = requests.head(self.url)

        security_headers = {
            "X-Frame-Options": None,
            "X-XSS-Protection": None,
            "Content-Security-Policy": None,
            # Add more headers you want to check here
        }

        for header_name in security_headers:
            header_value = response.headers.get(header_name)
            security_headers[header_name] = header_value

        # Print the results
        for header_name, header_value in security_headers.items():
            if header_value:
                print(f"[+] Found security header - {header_name}: {header_value}")
            else:
                print(f"[-] Missing security header - {header_name}")


    
    def perform_xss_scan(self):
        response = requests.get(self.url)
        soup = BeautifulSoup(response.text, "html.parser")

        input_fields = soup.find_all(["input", "textarea"])

        for field in input_fields:
            if field.get("type") not in ["hidden", "submit", "reset", "image", "button"]:
                for payload in self.payloads["xss"]:
                    # Inject the payload into the input field
                    field.attrs["value"] = payload

                    # Submit the form or trigger a request to check for XSS vulnerability
                    # For example:
                    # submit_form(soup)

                    # Restore the original value for the next iteration
                    field.attrs["value"] = ""


      
    def perform_sql_injection_scan(self):
        response = requests.get(self.url)
        soup = BeautifulSoup(response.text, "html.parser")

        input_fields = soup.find_all(["input", "textarea"])

        for field in input_fields:
            if field.get("type") not in ["hidden", "submit", "reset", "image", "button"]:
                for payload in self.payloads["sql_injection"]:
                    # Inject the payload into the input field
                    field.attrs["value"] = payload

                    # Submit the form or trigger a request to check for SQL injection vulnerability
                    # For example:
                    # submit_form(soup)

                    # Restore the original value for the next iteration
                    field.attrs["value"] = ""
      
    def perform_command_injection_scan(self):
        for payload in self.payloads["command_injection"]:
            target_url_with_payload = f"{self.url}/{payload}"

            try:
                # Execute the command and capture the output
                output = subprocess.check_output(["curl", target_url_with_payload], shell=True, stderr=subprocess.STDOUT)
                output = output.decode("utf-8").strip()
            except subprocess.CalledProcessError as e:
                output = e.output.decode("utf-8").strip()

            # Check if the payload is reflected in the output
            if payload in output:
                print(f"[+] Command Injection Vulnerability Found: {target_url_with_payload}")
                result = f"[+] Vulnerable"
            else:
                print(f"[-] Not Vulnerable to Command Injection: {target_url_with_payload}")
                result = f"[-] Not Vulnerable"

            # Save the result to the database
            self.save_scan_result("command_injection", target_url_with_payload, result)

        # Increment scan_iteration after each scan
        self.scan_iteration += 1

      
    def perform_csrf_scan(self):
        print("Performing CSRF Scan...")
        # Replace "csrf_token" with the actual name of the CSRF token parameter in your target's forms
        csrf_token_name = "csrf_token"
        
        # You may need to adjust the following data and headers based on your target's requirements
        post_data = {
            csrf_token_name: self.payloads["csrf"]
        }
        headers = {
            # Add any required headers here (e.g., User-Agent, Referer, etc.)
        }

        response = requests.post(self.url, data=post_data, headers=headers)

        # Check if the response indicates a successful CSRF attack (e.g., redirection or modification)
        if "successful-csrf-attack-indicator" in response.text:
            print("[+] CSRF Vulnerability Found: The website is vulnerable to CSRF attacks.")
            result = "[+] Vulnerable"
        else:
            print("[-] Not Vulnerable to CSRF: The website is protected against CSRF attacks.")
            result = "[-] Not Vulnerable"

        # Save the result to the database
        self.save_scan_result("csrf", self.url, result)

        # Increment scan_iteration after each scan
        self.scan_iteration += 1

    
    def perform_ssrf_scan(self):
        print("Performing SSRF Scan...")
        
        for payload in self.payloads["ssrf"]:
            target_url_with_payload = payload

            try:
                response = requests.get(target_url_with_payload)
                response.raise_for_status()  # Raise an exception for invalid HTTP responses (e.g., 404, 500)
            except requests.exceptions.RequestException as e:
                print(f"[-] Error: {str(e)}")
                result = f"[-] Error: {str(e)}"
            else:
                if "successful-ssrf-indicator" in response.text:
                    print(f"[+] SSRF Vulnerability Found: {target_url_with_payload}")
                    result = f"[+] Vulnerable"
                else:
                    print(f"[-] Not Vulnerable to SSRF: {target_url_with_payload}")
                    result = f"[-] Not Vulnerable"

            # Save the result to the database
            self.save_scan_result("ssrf", target_url_with_payload, result)

        # Increment scan_iteration after each scan
        self.scan_iteration += 1

    def vulnerability_scan(self, scan_type):
          if scan_type == 1:
             self.perform_header_scan()
          elif scan_type == 2:
             self.perform_xss_scan()
          elif scan_type == 3:
             self.perform_sql_injection_scan()
          elif scan_type == 4:
             self.perform_csrf_scan()
          elif scan_type == 5:
             self.perform_ssrf_scan()
          elif scan_type == 6:
             self.perform_command_injection_scan()
          elif scan_type == 10:
             # Scan for all vulnerabilities
             self.perform_header_scan()
             self.perform_xss_scan()
             self.perform_sql_injection_scan()
             self.perform_csrf_scan()
             self.perform_ssrf_scan()
             self.perform_command_injection_scan()
             # Add more vulnerability scans for other types if needed
          else:
             print("Invalid scan type.")          



                
class DatabaseHandler:
    def __init__(self):
        self.create_table()

    def create_table(self):
        connection = sqlite3.connect('scan_reports.db')
        cursor = connection.cursor()

        # Create a table to store vulnerabilities
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY,
                vulnerability_type TEXT,
                target_url TEXT,
                result TEXT,
                scan_time INTEGER  -- Add the scan_time field
            )
        ''')

        connection.commit()
        connection.close()

    def insert_scan_report(self, vulnerability_type, target_url, result, scan_time):
        connection = sqlite3.connect('scan_reports.db')
        cursor = connection.cursor()

        # Insert the scan report into the table
        cursor.execute('''
            INSERT INTO vulnerabilities (vulnerability_type, target_url, result, scan_time) 
            VALUES (?, ?, ?, ?)
        ''', (vulnerability_type, target_url, result, scan_time))

        connection.commit()
        connection.close()

def main():
    url = input("Enter the URL to scan: ")
    scanner = VulnerabilityScanner(url)

    scan_type = int(input("Choose the type of scan:\n1. Common Security Headers Scan\n2. XSS Scan\n3. SQL Injection Scan\n4. CSRF Scan\n5. SSRF Scan\n6. Command Injection Scan\n10. Scan All Vulnerabilities\n"))

    if scan_type == 10:
        # If the user chose to scan all vulnerabilities, perform the scans and store reports
        for individual_scan in [1, 2, 3, 4, 5, 6]:  # Add more vulnerability scans for other types if needed
            scanner.vulnerability_scan(individual_scan)

    else:
        # Perform the single selected scan type
        scanner.vulnerability_scan(scan_type)

    # Store the scan report in the database
    vulnerability_type = "Type of Vulnerability"  # Replace this with the actual type of vulnerability
    scan_report = "Store the scan result here"  # Replace this with the actual scan result

    db_handler = DatabaseHandler()
    db_handler.insert_scan_report(vulnerability_type, url, scan_report, scanner.scan_time)


if __name__ == "__main__":
    main()



