import requests
import json
import sqlite3
from bs4 import BeautifulSoup
import time
import tkinter as tk
from tkinter import scrolledtext
from tkinter import messagebox
from tkinter import ttk
import subprocess
class VulnerabilityScanner:
    def __init__(self, url):
        self.url = url
        self.payloads = self.load_payloads()
        self.scan_time = int(time.time())  # Get the current timestamp
        self.scan_iteration = 1

    def load_payloads(self):
        with open("payloads.json", "r") as f:
            return json.load(f)

    def perform_header_scan(self):
        print("Performing Header Scan...")
        response = requests.head(self.url)

        security_headers = {
            "X-Frame-Options": None,
            "X-XSS-Protection": None,
            "Content-Security-Policy": None,
            # Add more headers you want to check here
        }

        for header_name in security_headers:
            header_value = response.headers.get(header_name)
            security_headers[header_name] = header_value

        # Print the results
        for header_name, header_value in security_headers.items():
            if header_value:
                print(f"[+] Found security header - {header_name}: {header_value}")
            else:
                print(f"[-] Missing security header - {header_name}")

    def perform_xss_scan(self):
        response = requests.get(self.url)
        soup = BeautifulSoup(response.text, "html.parser")

        input_fields = soup.find_all(["input", "textarea"])

        for field in input_fields:
            if field.get("type") not in ["hidden", "submit", "reset", "image", "button"]:
                for payload in self.payloads["xss"]:
                    # Inject the payload into the input field
                    field.attrs["value"] = payload

                    # Submit the form or trigger a request to check for XSS vulnerability
                    # For example:
                    # submit_form(soup)

                    # Restore the original value for the next iteration
                    field.attrs["value"] = ""

    def perform_sql_injection_scan(self):
        response = requests.get(self.url)
        soup = BeautifulSoup(response.text, "html.parser")

        input_fields = soup.find_all(["input", "textarea"])

        for field in input_fields:
            if field.get("type") not in ["hidden", "submit", "reset", "image", "button"]:
                for payload in self.payloads["sql_injection"]:
                    # Inject the payload into the input field
                    field.attrs["value"] = payload

                    # Submit the form or trigger a request to check for SQL injection vulnerability
                    # For example:
                    # submit_form(soup)

                    # Restore the original value for the next iteration
                    field.attrs["value"] = ""

    def perform_command_injection_scan(self):
        for payload in self.payloads["command_injection"]:
            target_url_with_payload = f"{self.url}/{payload}"

            try:
                # Execute the command and capture the output
                output = subprocess.check_output(["curl", target_url_with_payload], shell=True, stderr=subprocess.STDOUT)
                output = output.decode("utf-8").strip()
            except subprocess.CalledProcessError as e:
                output = e.output.decode("utf-8").strip()

            # Check if the payload is reflected in the output
            if payload in output:
                print(f"[+] Command Injection Vulnerability Found: {target_url_with_payload}")
                result = f"[+] Vulnerable"
            else:
                print(f"[-] Not Vulnerable to Command Injection: {target_url_with_payload}")
                result = f"[-] Not Vulnerable"

            # Save the result to the database
            self.save_scan_result("command_injection", target_url_with_payload, result)

        # Increment scan_iteration after each scan
        self.scan_iteration += 1

    def perform_csrf_scan(self):
        print("Performing CSRF Scan...")
        # Replace "csrf_token" with the actual name of the CSRF token parameter in your target's forms
        csrf_token_name = "csrf_token"

        # You may need to adjust the following data and headers based on your target's requirements
        post_data = {
            csrf_token_name: self.payloads["csrf"]
        }
        headers = {
            # Add any required headers here (e.g., User-Agent, Referer, etc.)
            #  "X-Frame-Options": None,
            # "X-XSS-Protection": None,
            # "Content-Security-Policy": None,
            # "Strict-Transport-Security": None,
            # "X-Content-Type-Options": None,
            # "Referrer-Policy": None,
            # "Feature-Policy": None,
            # "X-Content-Security-Policy": None,  # For older versions of Firefox
            # "X-WebKit-CSP": None,  # For older versions of Chrome/Safari
            # Add more headers you want to check here
        }

        response = requests.post(self.url, data=post_data, headers=headers)

        # Check if the response indicates a successful CSRF attack (e.g., redirection or modification)
        if "successful-csrf-attack-indicator" in response.text:
            print("[+] CSRF Vulnerability Found: The website is vulnerable to CSRF attacks.")
            result = "[+] Vulnerable"
        else:
            print("[-] Not Vulnerable to CSRF: The website is protected against CSRF attacks.")
            result = "[-] Not Vulnerable"

        # Save the result to the database
        self.save_scan_result("csrf", self.url, result)

        # Increment scan_iteration after each scan
        self.scan_iteration += 1

    def perform_ssrf_scan(self):
        print("Performing SSRF Scan...")

        for payload in self.payloads["ssrf"]:
            target_url_with_payload = payload

            try:
                response = requests.get(target_url_with_payload)
                response.raise_for_status()  # Raise an exception for invalid HTTP responses (e.g., 404, 500)
            except requests.exceptions.RequestException as e:
                print(f"[-] Error: {str(e)}")
                result = f"[-] Error: {str(e)}"
            else:
                if "successful-ssrf-indicator" in response.text:
                    print(f"[+] SSRF Vulnerability Found: {target_url_with_payload}")
                    result = f"[+] Vulnerable"
                else:
                    print(f"[-] Not Vulnerable to SSRF: {target_url_with_payload}")
                    result = f"[-] Not Vulnerable"

            # Save the result to the database
            self.save_scan_result("ssrf", target_url_with_payload, result)

        # Increment scan_iteration after each scan
        self.scan_iteration += 1

    def vulnerability_scan(self, scan_type):
        if scan_type == 1:
            self.perform_header_scan()
        elif scan_type == 2:
            self.perform_xss_scan()
        elif scan_type == 3:
            self.perform_sql_injection_scan()
        elif scan_type == 4:
            self.perform_csrf_scan()
        elif scan_type == 5:
            self.perform_ssrf_scan()
        elif scan_type == 6:
            self.perform_command_injection_scan()
        elif scan_type == 10:
            # Scan for all vulnerabilities
            self.perform_header_scan()
            self.perform_xss_scan()
            self.perform_sql_injection_scan()
            self.perform_csrf_scan()
            self.perform_ssrf_scan()
            self.perform_command_injection_scan()
            # Add more vulnerability scans for other types if needed
        else:
            print("Invalid scan type.")

    def save_scan_result(self, vulnerability_type, target_url, result):
        connection = sqlite3.connect('scan_reports.db')
        cursor = connection.cursor()

        # Insert the scan report into the table
        cursor.execute('''
            INSERT INTO vulnerabilities (vulnerability_type, target_url, result, scan_time) 
            VALUES (?, ?, ?, ?)
        ''', (vulnerability_type, target_url, result, self.scan_time))

        connection.commit()
        connection.close()


class DatabaseHandler:
    def __init__(self):
        self.create_table()

    def create_table(self):
        connection = sqlite3.connect('scan_reports.db')
        cursor = connection.cursor()

        # Create a table to store vulnerabilities
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY,
                vulnerability_type TEXT,
                target_url TEXT,
                result TEXT,
                scan_time INTEGER  -- Add the scan_time field
            )
        ''')

        connection.commit()
        connection.close()

    def insert_scan_report(self, vulnerability_type, target_url, result, scan_time):
        connection = sqlite3.connect('scan_reports.db')
        cursor = connection.cursor()

        # Insert the scan report into the table
        cursor.execute('''
            INSERT INTO vulnerabilities (vulnerability_type, target_url, result, scan_time) 
            VALUES (?, ?, ?, ?)
        ''', (vulnerability_type, target_url, result, scan_time))

        connection.commit()
        connection.close()

# Global variables
results_textbox = None
url_entry = None
scan_type_var = None  # Declare scan_type_var globally


scan_types = [
        ("Common Security Headers Scan", 1),
        ("XSS Scan", 2),
        ("SQL Injection Scan", 3),
        ("CSRF Scan", 4),
        ("SSRF Scan", 5),
        ("Command Injection Scan", 6),
        ("Scan All Vulnerabilities", 10),
    ]


def scan_website():
    global results_textbox, url_entry

    target_url = url_entry.get().strip()  # Get the URL and remove any leading/trailing whitespaces
    if not target_url:
        messagebox.showerror("Error", "Please enter a website URL.")
        return

    scanner = VulnerabilityScanner(target_url)
    scanner.create_table()  # Move the table creation here to ensure it's created before each scan

    # Clear the previous scanning results
    results_textbox.delete(1.0, tk.END)

    # Get the current scan iteration
    current_scan_iteration = scanner.scan_iteration

    # Get the selected scan type
    scan_type = scan_type_var.get()

    if scan_type == 10:
        # If the user chose to scan all vulnerabilities, perform the scans and store reports
        for individual_scan in [1, 2, 3, 4, 5, 6]:  # Add more vulnerability scans for other types if needed
            scanner.vulnerability_scan(individual_scan)
    else:
        # Perform the single selected scan type
        scanner.vulnerability_scan(scan_type)

    # Show the results in the GUI
    show_results(scanner.scan_time)


def show_results(scan_time):
    connection = sqlite3.connect('scan_reports.db')
    cursor = connection.cursor()

    # Fetch the scan reports from the database
    cursor.execute('SELECT vulnerability_type, target_url, result FROM vulnerabilities WHERE scan_time=?', (scan_time,))
    scan_reports = cursor.fetchall()

    connection.close()

    # Display the results in the scrolledtext widget
    results_textbox.delete(1.0, tk.END)
    for report in scan_reports:
        results_textbox.insert(tk.END, f"{report[0]} - {report[1]}: {report[2]}\n")


def main():
    global url_entry, results_textbox, scan_type_var

    root = tk.Tk()
    root.title("Vulnerability Scanner")

    url_label = tk.Label(root, text="Enter the website URL:")
    url_label.pack(pady=5)

    url_entry = tk.Entry(root, width=50)
    url_entry.pack(pady=5)

    scan_type_var = tk.IntVar()
    scan_type_var.set(0)  # Set default scan type to None

    scan_type_label = tk.Label(root, text="Choose the type of scan:")
    scan_type_label.pack(pady=5)

    for scan_type, value in scan_types:
        scan_type_checkbox = ttk.Checkbutton(root, text=scan_type, variable=scan_type_var, onvalue=value, offvalue=0)
        scan_type_checkbox.pack(anchor=tk.W)

    # Style for the buttons
    style = ttk.Style()
    style.configure("Scan.TButton", font=("Arial", 12), foreground="white", background="green", padding=10)
    style.map("Scan.TButton", background=[("active", "darkgreen")])

    scan_button = ttk.Button(root, text="Scan", command=scan_website, style="Scan.TButton")
    scan_button.pack(pady=10)

    results_textbox = scrolledtext.ScrolledText(root, width=80, height=20, wrap=tk.WORD)
    results_textbox.pack(pady=5)

    root.mainloop()


if __name__ == "__main__":
    main()




"""
import requests
import json
import sqlite3
from bs4 import BeautifulSoup
import time
import tkinter as tk
from tkinter import scrolledtext
from tkinter import messagebox
from tkinter import ttk

class VulnerabilityScanner:
    def __init__(self, url):
        self.url = url
        self.payloads = self.load_payloads()
        self.scan_time = int(time.time())  # Get the current timestamp
        self.scan_iteration = 1

    def load_payloads(self):
        with open("payloads.json", "r") as f:
            return json.load(f)

    def perform_header_scan(self):
        print("Performing Header Scan...")
        response = requests.head(self.url)

        security_headers = {
            "X-Frame-Options": None,
            "X-XSS-Protection": None,
            "Content-Security-Policy": None,
            # Add more headers you want to check here
        }

        for header_name in security_headers:
            header_value = response.headers.get(header_name)
            security_headers[header_name] = header_value

        # Print the results
        for header_name, header_value in security_headers.items():
            if header_value:
                print(f"[+] Found security header - {header_name}: {header_value}")
            else:
                print(f"[-] Missing security header - {header_name}")

    def perform_xss_scan(self):
        response = requests.get(self.url)
        soup = BeautifulSoup(response.text, "html.parser")

        input_fields = soup.find_all(["input", "textarea"])

        for field in input_fields:
            if field.get("type") not in ["hidden", "submit", "reset", "image", "button"]:
                for payload in self.payloads["xss"]:
                    # Inject the payload into the input field
                    field.attrs["value"] = payload

                    # Submit the form or trigger a request to check for XSS vulnerability
                    # For example:
                    # submit_form(soup)

                    # Restore the original value for the next iteration
                    field.attrs["value"] = ""

    def perform_sql_injection_scan(self):
        response = requests.get(self.url)
        soup = BeautifulSoup(response.text, "html.parser")

        input_fields = soup.find_all(["input", "textarea"])

        for field in input_fields:
            if field.get("type") not in ["hidden", "submit", "reset", "image", "button"]:
                for payload in self.payloads["sql_injection"]:
                    # Inject the payload into the input field
                    field.attrs["value"] = payload

                    # Submit the form or trigger a request to check for SQL injection vulnerability
                    # For example:
                    # submit_form(soup)

                    # Restore the original value for the next iteration
                    field.attrs["value"] = ""

    def perform_command_injection_scan(self):
        for payload in self.payloads["command_injection"]:
            target_url_with_payload = f"{self.url}/{payload}"

            try:
                # Execute the command and capture the output
                output = subprocess.check_output(["curl", target_url_with_payload], shell=True, stderr=subprocess.STDOUT)
                output = output.decode("utf-8").strip()
            except subprocess.CalledProcessError as e:
                output = e.output.decode("utf-8").strip()

            # Check if the payload is reflected in the output
            if payload in output:
                print(f"[+] Command Injection Vulnerability Found: {target_url_with_payload}")
                result = f"[+] Vulnerable"
            else:
                print(f"[-] Not Vulnerable to Command Injection: {target_url_with_payload}")
                result = f"[-] Not Vulnerable"

            # Save the result to the database
            self.save_scan_result("command_injection", target_url_with_payload, result)

        # Increment scan_iteration after each scan
        self.scan_iteration += 1

    def perform_csrf_scan(self):
        print("Performing CSRF Scan...")
        # Replace "csrf_token" with the actual name of the CSRF token parameter in your target's forms
        csrf_token_name = "csrf_token"

        # You may need to adjust the following data and headers based on your target's requirements
        post_data = {
            csrf_token_name: self.payloads["csrf"]
        }
        headers = {
            # Add any required headers here (e.g., User-Agent, Referer, etc.)
            #  "X-Frame-Options": None,
            # "X-XSS-Protection": None,
            # "Content-Security-Policy": None,
            # "Strict-Transport-Security": None,
            # "X-Content-Type-Options": None,
            # "Referrer-Policy": None,
            # "Feature-Policy": None,
            # "X-Content-Security-Policy": None,  # For older versions of Firefox
            # "X-WebKit-CSP": None,  # For older versions of Chrome/Safari
            # Add more headers you want to check here
        }

        response = requests.post(self.url, data=post_data, headers=headers)

        # Check if the response indicates a successful CSRF attack (e.g., redirection or modification)
        if "successful-csrf-attack-indicator" in response.text:
            print("[+] CSRF Vulnerability Found: The website is vulnerable to CSRF attacks.")
            result = "[+] Vulnerable"
        else:
            print("[-] Not Vulnerable to CSRF: The website is protected against CSRF attacks.")
            result = "[-] Not Vulnerable"

        # Save the result to the database
        self.save_scan_result("csrf", self.url, result)

        # Increment scan_iteration after each scan
        self.scan_iteration += 1

    def perform_ssrf_scan(self):
        print("Performing SSRF Scan...")

        for payload in self.payloads["ssrf"]:
            target_url_with_payload = payload

            try:
                response = requests.get(target_url_with_payload)
                response.raise_for_status()  # Raise an exception for invalid HTTP responses (e.g., 404, 500)
            except requests.exceptions.RequestException as e:
                print(f"[-] Error: {str(e)}")
                result = f"[-] Error: {str(e)}"
            else:
                if "successful-ssrf-indicator" in response.text:
                    print(f"[+] SSRF Vulnerability Found: {target_url_with_payload}")
                    result = f"[+] Vulnerable"
                else:
                    print(f"[-] Not Vulnerable to SSRF: {target_url_with_payload}")
                    result = f"[-] Not Vulnerable"

            # Save the result to the database
            self.save_scan_result("ssrf", target_url_with_payload, result)

        # Increment scan_iteration after each scan
        self.scan_iteration += 1

    def vulnerability_scan(self, scan_type):
        if scan_type == 1:
            self.perform_header_scan()
        elif scan_type == 2:
            self.perform_xss_scan()
        elif scan_type == 3:
            self.perform_sql_injection_scan()
        elif scan_type == 4:
            self.perform_csrf_scan()
        elif scan_type == 5:
            self.perform_ssrf_scan()
        elif scan_type == 6:
            self.perform_command_injection_scan()
        elif scan_type == 10:
            # Scan for all vulnerabilities
            self.perform_header_scan()
            self.perform_xss_scan()
            self.perform_sql_injection_scan()
            self.perform_csrf_scan()
            self.perform_ssrf_scan()
            self.perform_command_injection_scan()
            # Add more vulnerability scans for other types if needed
        else:
            print("Invalid scan type.")

    def save_scan_result(self, vulnerability_type, target_url, result):
        connection = sqlite3.connect('scan_reports.db')
        cursor = connection.cursor()

        # Insert the scan report into the table
        cursor.execute('''
            INSERT INTO vulnerabilities (vulnerability_type, target_url, result, scan_time) 
            VALUES (?, ?, ?, ?)
        ''', (vulnerability_type, target_url, result, self.scan_time))

        connection.commit()
        connection.close()


class DatabaseHandler:
    def __init__(self):
        self.create_table()

    def create_table(self):
        connection = sqlite3.connect('scan_reports.db')
        cursor = connection.cursor()

        # Create a table to store vulnerabilities
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY,
                vulnerability_type TEXT,
                target_url TEXT,
                result TEXT,
                scan_time INTEGER  -- Add the scan_time field
            )
        ''')

        connection.commit()
        connection.close()

    def insert_scan_report(self, vulnerability_type, target_url, result, scan_time):
        connection = sqlite3.connect('scan_reports.db')
        cursor = connection.cursor()

        # Insert the scan report into the table
        cursor.execute('''
            INSERT INTO vulnerabilities (vulnerability_type, target_url, result, scan_time) 
            VALUES (?, ?, ?, ?)
        ''', (vulnerability_type, target_url, result, scan_time))

        connection.commit()
        connection.close()

# Global variables
results_textbox = None
url_entry = None
scan_types = [
    ("Common Security Headers Scan", 1),
    ("XSS Scan", 2),
    ("SQL Injection Scan", 3),
    ("CSRF Scan", 4),
    ("SSRF Scan", 5),
    ("Command Injection Scan", 6),
    ("Scan All Vulnerabilities", 10),
]

# Initialize dictionaries to store IntVar and Checkbutton objects
scan_type_var = {}
scan_type_checkbox = {}

def scan_website():
    global results_textbox, url_entry

    target_url = url_entry.get().strip()  # Get the URL and remove any leading/trailing whitespaces
    if not target_url:
        messagebox.showerror("Error", "Please enter a website URL.")
        return

    scanner = VulnerabilityScanner(target_url)
    scanner.create_table()  # Move the table creation here to ensure it's created before each scan

    # Clear the previous scanning results
    results_textbox.delete(1.0, tk.END)

    # Get the current scan iteration
    current_scan_iteration = scanner.scan_iteration

    # Get the selected scan type
    scan_type = scan_type_var.get()

    if scan_type == 10:
        # If the user chose to scan all vulnerabilities, perform the scans and store reports
        for individual_scan in [1, 2, 3, 4, 5, 6]:  # Add more vulnerability scans for other types if needed
            scanner.vulnerability_scan(individual_scan)
    else:
        # Perform the single selected scan type
        scanner.vulnerability_scan(scan_type)

    # Show the results in the GUI
    show_results(scanner.scan_time)

def on_checkbox_change():
    global scan_type_var, scan_type_checkbox

    # Get the number of selected checkboxes
    num_selected = sum(scan_type_var[i].get() for i in scan_type_var)

    # Disable further selections if the limit (5) is reached
    if num_selected > 5:
        for i in scan_type_var:
            if scan_type_var[i].get() == 0:
                scan_type_checkbox[i].config(state="disabled")
    else:
        for i in scan_type_var:
            scan_type_checkbox[i].config(state="normal")



def show_results(scan_time):
    connection = sqlite3.connect('scan_reports.db')
    cursor = connection.cursor()

    # Fetch the scan reports from the database
    cursor.execute('SELECT vulnerability_type, target_url, result FROM vulnerabilities WHERE scan_time=?', (scan_time,))
    scan_reports = cursor.fetchall()

    connection.close()

    # Display the results in the scrolledtext widget
    results_textbox.delete(1.0, tk.END)
    for report in scan_reports:
        results_textbox.insert(tk.END, f"{report[0]} - {report[1]}: {report[2]}\n")


def main():
    global url_entry, results_textbox

    root = tk.Tk()
    root.title("Vulnerability Scanner")

    url_label = tk.Label(root, text="Enter the website URL:")
    url_label.pack(pady=5)

    url_entry = tk.Entry(root, width=50)
    url_entry.pack(pady=5)

    scan_types = [
        ("Common Security Headers Scan", 1),
        ("XSS Scan", 2),
        ("SQL Injection Scan", 3),
        ("CSRF Scan", 4),
        ("SSRF Scan", 5),
        ("Command Injection Scan", 6),
        ("Scan All Vulnerabilities", 10),
    ]
    scan_type_var = tk.IntVar()
    scan_type_var.set(0)  # Set default scan type to None

    scan_type_label = tk.Label(root, text="Choose the type of scan:")
    scan_type_label.pack(pady=5)

    scan_type_var = {}  # Dictionary to store IntVar objects
scan_type_checkbox = {}  # Dictionary to store Checkbutton objects

for i, (scan_type, value) in enumerate(scan_types):
    scan_type_var[i] = tk.IntVar()  # Create an IntVar for each checkbox
    scan_type_checkbox[i] = ttk.Checkbutton(root, text=scan_type, variable=scan_type_var[i], onvalue=value, offvalue=0, command=on_checkbox_change)
    scan_type_checkbox[i].pack(anchor=tk.W)
    scan_type_checkbox[i].config(state="normal")


    # for scan_type, value in scan_types:
    #     scan_type_checkbox = ttk.Checkbutton(root, text=scan_type, variable=scan_type_var, onvalue=value, offvalue=0)
    #     scan_type_checkbox.pack(anchor=tk.W)

    # Style for the buttons
    style = ttk.Style()
    style.configure("Scan.TButton", font=("Arial", 12), foreground="white", background="green", padding=10)
    style.map("Scan.TButton", background=[("active", "darkgreen")])

    scan_button = ttk.Button(root, text="Scan", command=scan_website, style="Scan.TButton")
    scan_button.pack(pady=10)

    results_textbox = scrolledtext.ScrolledText(root, width=80, height=20, wrap=tk.WORD)
    results_textbox.pack(pady=5)

    root.mainloop()


if __name__ == "__main__":
    main()

"""