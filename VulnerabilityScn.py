import requests
from bs4 import BeautifulSoup
import json
import sqlite3
import tkinter as tk
from tkinter import scrolledtext
from tkinter import messagebox
import os
import time

class VulnerabilityScanner:
    def __init__(self):
        self.payloads = self.load_payloads()
        self.db_name = f"vulnerabilities.db" #DB created in single file.
        
    def load_payloads(self):
        with open("payloads.json") as file:
            payloads_data = json.load(file)
        return payloads_data
    
    def create_table(self):
        try:
            db_path = os.path.join(os.getcwd(), self.db_name)
            connection = sqlite3.connect(db_path)
            cursor = connection.cursor()

            cursor.execute('''
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    id INTEGER PRIMARY KEY,
                    vulnerability_type TEXT,
                    scan_iteration INTEGER,
                    target_url TEXT,
                    result TEXT
                    
                )
            ''')

            connection.commit()
            connection.close()
        except sqlite3.Error as e:
            messagebox.showerror("Error", f"Database Error: {str(e)}")

    def check_vulnerability(self, target_url, vulnerability_type, results_textbox, scan_iteration):
        if vulnerability_type not in self.payloads:
            results_textbox.insert(tk.END, f"Unknown vulnerability type: {vulnerability_type}\n")
            return

        results_textbox.insert(tk.END, f"Checking for {vulnerability_type} vulnerability...\n")
        connection = sqlite3.connect('vulnerabilities.db')
        cursor = connection.cursor()

        for payload in self.payloads[vulnerability_type]:
            target_url_with_payload = f"{target_url}/{payload}"
            try:
                response = requests.get(target_url_with_payload)
                response.raise_for_status()  # Raise an exception for invalid HTTP responses (e.g., 404, 500)
            except requests.exceptions.RequestException as e:
                results_textbox.insert(tk.END, f"[-] Error: {str(e)}\n")
                result = f"[-] Error: {str(e)}"
            else:
                soup = BeautifulSoup(response.text, 'html.parser')
                if payload in soup:
                    results_textbox.insert(tk.END, f"[+] {vulnerability_type} Vulnerability Found: {target_url_with_payload}\n")
                    result = f"[+] Vulnerable"
                    # Display pop-up message for the specific vulnerability found
                    messagebox.showinfo("Vulnerability Found", f"{vulnerability_type} vulnerability found at:\n{target_url_with_payload}")
                else:
                    results_textbox.insert(tk.END, f"[-] Not Vulnerable to {vulnerability_type}: {target_url_with_payload}\n")
                    result = f"[-] Not Vulnerable"

            # Save the result to the database
            try:
                db_path = os.path.join(os.getcwd(), self.db_name)
                connection = sqlite3.connect(db_path)
                cursor = connection.cursor()

                cursor.execute('INSERT INTO vulnerabilities (vulnerability_type, target_url, result, scan_iteration) VALUES (?, ?, ?, ?)', (vulnerability_type, target_url_with_payload, result, scan_iteration))
                connection.commit()
                connection.close()
            except sqlite3.Error as e:
                messagebox.showerror("Error", f"Database Error: {str(e)}")

        connection.close()


def scan_website():
    target_url = url_entry.get().strip()  # Get the URL and remove any leading/trailing whitespaces
    if not target_url:
        messagebox.showerror("Error", "Please enter a website URL.")
        return
    
    scanner = VulnerabilityScanner()
    scanner.create_table()  # Move the table creation here to ensure it's created before each scan
    

    # Clear the previous scanning results
    results_textbox.delete(1.0, tk.END)

   
    # Get the current scan iteration
    current_scan_iteration = int(time.time())

    # Run vulnerability scans for all types
    for vulnerability_type in scanner.payloads.keys():
        scanner.check_vulnerability(target_url, vulnerability_type, results_textbox, current_scan_iteration)


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Vulnerability Scanner")

    url_label = tk.Label(root, text="Enter the website URL:")
    url_label.pack(pady=5)

    url_entry = tk.Entry(root, width=50)
    url_entry.pack(pady=5)

    scan_button = tk.Button(root, text="Scan", command=scan_website)
    scan_button.pack(pady=10)

    results_textbox = scrolledtext.ScrolledText(root, width=80, height=20, wrap=tk.WORD)
    results_textbox.pack(pady=5)

    root.mainloop()
